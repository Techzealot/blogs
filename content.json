[{"title":"(6)go数组","date":"2020-05-08T17:36:17.000Z","path":"2020/05/09/go数组/","text":"本章主要介绍数组的定义、使用、遍历、值类型 数组定义func main() &#123; //默认初始化 var arr1 [5]int arr2 := [3]int&#123;1, 3, 5&#125; //编译器推断 arr3 := [...]int&#123;2, 4, 6, 8, 10&#125; fmt.Println(arr1, arr2, arr3) //[0 0 0 0 0] [1 3 5] [2 4 6 8 10] //4行5列二维数组 var grade [4][5]bool fmt.Println(grade) //[[false false false false false] [false false false false false] [false false false false false] [false false false false false]]&#125; 数组的遍历func main() &#123; //编译器推断 arr3 := [...]int&#123;2, 4, 6, 8, 10&#125; //强烈不推荐，其他语言的做法 for i := 0; i &lt; len(arr3); i++ &#123; fmt.Println(arr3[i]) &#125; for i := range arr3 &#123; fmt.Println(arr3[i]) &#125; //推荐做法,可同时获取索引和值,_可以省略变量 for _, v := range arr3 &#123; fmt.Println(v) &#125;&#125; range 的好处：简单明确，可同时获取索引和对应值 数组是值类型//数组的值会拷贝过来，原数组不会被改变func printArray(arr [5]int) &#123; arr[0] = 100 for i, v := range arr &#123; fmt.Println(i, v) &#125;&#125;//可传递指针来改变原数组func printArrayWithEffect(arr *[5]int) &#123; //此处等价于 (*arr)[0] = 100,语法处理，arr并不是数组的头指针（不同于C） arr[0] = 100 for i, v := range arr &#123; fmt.Println(i, v) &#125;&#125;func main() &#123; //编译器推断 arr3 := [...]int&#123;2, 4, 6, 8, 10&#125; printArray(arr3) fmt.Println(arr3) //[2 4 6 8 10] printArrayWithEffect(&amp;arr3) fmt.Println(arr3) //[100 4 6 8 10]&#125; 在go语言中一般不使用数组或数组指针作为参数，而是使用切片（详见下章）","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(5)go指针","date":"2020-05-08T16:45:14.000Z","path":"2020/05/09/go指针/","text":"本章主要介绍go语言指针用法及注意事项 go语言指针不能参与运算，但可以改变指向func main() &#123; var a int = 2 var pa *int = &amp;a *pa = 3 fmt.Println(a, pa, *pa, &amp;pa, &amp;a) //3 0xc00000a0e8 3 0xc000006028 0xc00000a0e8&#125; go语言函数参数是值传递go语言只有值传递一种形式： 默认通过数据拷贝进行值传递，可通过传递指针实现传递引用的效果 因此在设计对象时就应该考虑传递形式 func passByValue(a int) &#123; a++&#125;func passByRef(a *int) &#123; *a++&#125;func main() &#123; a := 2 passByValue(a) fmt.Println(a) //2 passByRef(&amp;a) fmt.Println(a) //3&#125; go语言支持多重赋值两个变量交换不需要引入第三个参数 a,b int=3,4a,b=b,a 交换函数实现//推荐做法func swapNoSideEffect(a, b int) (int, int) &#123; return b, a&#125;func swap(a, b *int) &#123; *a, *b = *b, *a&#125;func main() &#123; c, d := 5, 6 swap(&amp;c, &amp;d) fmt.Println(c, d) //6,5 c, d = swapNoSideEffect(c, d) fmt.Println(c, d) //5,6 var e int c, d, e = d, c, d/c fmt.Println(c, d, e) //6 5 1 将右侧变量先运算替换，然后一次赋多值&#125;","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(4)go函数","date":"2020-05-07T16:51:42.000Z","path":"2020/05/08/go函数/","text":"本章主要介绍了go的函数定义及使用，函数式编程，可变参数列表 go函数可以返回多个值,而且可以命名 //不要滥用多值返回，一般最后一个为errorfunc div(a, b int) (q, r int) &#123; return a / b, a % b&#125;func evalSilent(a, b int, op string) (int, error) &#123; switch op &#123; case \"+\": return a + b, nil case \"-\": return a - b, nil case \"*\": return a * b, nil case \"/\": return a / b, nil case \"%\": _, r := div(a, b) return r, nil default: return 0, fmt.Errorf(\"unsupport op : %s\", op) &#125;&#125;func main() &#123; fmt.Println(div(13, 3)) if result, err := evalSilent(13, 3, \"x\"); err != nil &#123; fmt.Println(\"error\", err) &#125; else &#123; fmt.Println(result) &#125;&#125; 函数式编程函数参数和返回值也可以是函数 func apply(op func(int, int) int, a, b int) int &#123; p := reflect.ValueOf(op).Pointer() opName := runtime.FuncForPC(p).Name() fmt.Printf(\"calling function %s with args (%d,%d) \\n\", opName, a, b) return op(a, b)&#125;func main() &#123; //匿名函数 fmt.Println(apply(func(a int, b int) int &#123; return int(math.Pow(float64(a), float64(b))) &#125;, 3, 4))&#125; 可变参数func sum(numbers ...int) int &#123; s := 0 for i := range numbers &#123; s += numbers[i] &#125; return s&#125;func main() &#123; fmt.Println(sum(1, 2, 3, 4, 5))&#125;","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(3)go控制结构","date":"2020-05-07T15:30:44.000Z","path":"2020/05/07/go控制结构/","text":"本章主要介绍了go语言的流程控制结构if,switch,for的常见用法 1. ifform 1 func main() &#123; const filename = \"abc.txt\" file, err := ioutil.ReadFile(filename) if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Printf(\"%s\\n\", file) &#125;&#125; form 2（推荐） func main() &#123; const filename = \"abc.txt\" //file作用域在if语句内 if file, err := ioutil.ReadFile(filename); err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Printf(\"%s\\n\", file) &#125;&#125; 2. switchswitch默认会break除非使用fallthrough form 1 func eval(a, b int, op string) int &#123; switch op &#123; case \"+\": return a + b case \"-\": return a - b case \"*\": return a * b case \"/\": return a / b default: panic(\"unsupported op:\" + op) &#125;&#125; form 2: switch后没有表达式，case中有表达式 func grade(score int) string &#123; g := \"\" switch &#123; case score &lt; 0 || score &gt; 100: panic(fmt.Sprintf(\"wrong score %d \\n\", score)) case score &lt; 60: g = \"F\" case score &lt; 80: g = \"C\" case score &lt; 90: g = \"B\" case score &lt; 00: g = \"A\" &#125; return g&#125; 3. forform 1 for的条件里不需要括号 for可以省略初始条件、结束表达式、自增条件 func loop() &#123; sum := 0 for i := 0; i &lt; 100; i++ &#123; sum += i &#125;&#125; form 2 省略初始条件 func convertToBin(n int) string &#123; if n == 0 &#123; return \"0\" &#125; result := \"\" for ; n &gt; 0; n /= 2 &#123; lsb := n % 2 result = strconv.Itoa(lsb) + result &#125; return result&#125; form 3 省略结束条件、递增条件，此时相当于while func printFile(filename string) &#123; file, err := os.Open(filename) if err != nil &#123; panic(err) &#125; scanner := bufio.NewScanner(file) for scanner.Scan() &#123; fmt.Println(scanner.Text()) &#125;&#125; form 4 省略结束条件 func forever() &#123; for &#123; fmt.Println(\"forever\") &#125;&#125;","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(2)go语言常量","date":"2020-05-07T14:41:21.000Z","path":"2020/05/07/go语言常量/","text":"本章主要介绍了go语言的常量、枚举及iota的使用 1. 常量const ( d = 1 e = 2)func consts() &#123; const filename = \"abc.txt\" //常量可以当做各种类型使用，相当于文本替换 const a, b = 3, 4 var c int //此处无需强转 c = int(math.Sqrt(a*a + b*b)) fmt.Println(c)&#125; 2. 枚举类型func enums() &#123; /*const ( cpp = 0 java = 1 python = 2 golang = 3 )*/ const ( cpp = iota //0 _ //1 python // 2 golang //3 ) //b kb mb gb tb pb const ( b = 1 &lt;&lt; (10 * iota) //1 &lt;&lt; (10*0) kb //1 &lt;&lt; (10*1) mb //1 &lt;&lt; (10*2) gb //1 &lt;&lt; (10*3) tb //1 &lt;&lt; (10*4) pb //1 &lt;&lt; (10*5) ) fmt.Println(b, kb, mb, gb, tb, pb) //1 1024 1048576 1073741824 1099511627776 1125899906842624 fmt.Println(cpp, python, golang) //0 2 3&#125; iota 自增量种子 可以参与运算","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(1)go语言变量","date":"2020-05-06T17:56:58.000Z","path":"2020/05/07/go语言变量/","text":"本章主要介绍了变量的定义及使用，基本数据类型，类型转换 1. 变量定义1.1 局部变量var a int =3var a,b int =3,4//类型推断var a,b,c,d = 3,4,true,\"abc\"// := 定义并初始化 推荐使用a,b,c,d := 3,4,true,\"abc\" 1.2 包内变量//包内部变量必须使用var定义，无全局变量var aa = 1// () 可以省略多个varvar ( bb = 2 cc = 3 dd = 4) 1.3 复数使用//验证欧拉公式func euler() &#123; c := 3 + 4i fmt.Println(cmplx.Abs(c)) eu := cmplx.Pow(math.E, 1i*math.Pi) + 1 fmt.Println(eu) eu = cmplx.Exp(1i*math.Pi) + 1 fmt.Printf(\"%3f \\n\", eu)&#125; 2. 类型转换必须显式声明//类型转换采用 T() 形式func triangle() &#123; a, b := 3, 4 var c int c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c)&#125; 3. 基本数据类型整型 类型 描述 uint8 无符号 8位整型 (0 到 255) uint16 无符号 16位整型 (0 到 65535) uint32 无符号 32位整型 (0 到 4294967295) uint64 无符号 64位整型 (0 到 18446744073709551615) int8 有符号 8位整型 (-128 到 127) int16 有符号 16位整型 (-32768 到 32767) int32 有符号 32位整型 (-2147483648 到 2147483647) int64 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) 特殊整型 类型 描述 uint 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 浮点型float32和float64 复数complex64和complex128 c := 3 + 4ifmt.Println(cmplx.Abs(c)) 布尔值Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。 注意： 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换 字符串Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(&quot;)中的内容，可以在Go语言的源码中直接添加非ASCII码字符 Go语言中要定义一个多行字符串时，就必须使用反引号字符 str := \"hello world\"ch := \"中文\"const str = ` 第一行第二行第三行\\r\\n`fmt.Println(str) byte和rune类型Go 语言的字符有以下两种： uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 UTF-8字符。 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"MAT排查问题思路","date":"2020-01-16T05:50:39.000Z","path":"2020/01/16/MAT排查问题思路/","text":"MAT分析jvm内存转储文件思路及操作： 查看leak suspect 查看Histogram分布 (按retainSize降序) merge shortest path to GC root (按retainSize降序) list objects with incoming/outcoming (按retainSize降序) 在big map上执行java collection &gt; collections group by size (按retainSize降序) 1-5按情况交叉执行","tags":[{"name":"jvm","slug":"jvm","permalink":"https://techzealot.github.io/tags/jvm/"},{"name":"mat","slug":"mat","permalink":"https://techzealot.github.io/tags/mat/"}]},{"title":"truffle与graalVM","date":"2019-03-04T17:35:38.000Z","path":"2019/03/05/truffle与graalVM/","text":"","tags":[]},{"title":"TCP/IP协议详解","date":"2019-02-20T16:52:24.000Z","path":"2019/02/21/TCP-IP协议详解/","text":"","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://techzealot.github.io/tags/TCP-IP/"}]},{"title":"java Class文件结构","date":"2019-02-20T15:23:35.000Z","path":"2019/02/20/java-Class文件结构/","text":"todo","tags":[{"name":"JVM","slug":"JVM","permalink":"https://techzealot.github.io/tags/JVM/"},{"name":"class","slug":"class","permalink":"https://techzealot.github.io/tags/class/"},{"name":"编译器","slug":"编译器","permalink":"https://techzealot.github.io/tags/编译器/"}]},{"title":"guice官方文档中文版","date":"2018-12-21T05:02:48.000Z","path":"2018/12/21/guice官方文档中文版/","text":"","tags":[]},{"title":"springboot实现指定范围内随机选取可用端口","date":"2018-12-20T07:57:04.000Z","path":"2018/12/20/springboot实现指定范围内随机选取可用端口/","text":"","tags":[]},{"title":"DeferredResult实现http long pulling","date":"2018-12-20T07:55:18.000Z","path":"2018/12/20/DeferredResult实现http-long-pulling/","text":"","tags":[]},{"title":"spock单元测试","date":"2018-12-20T07:53:18.000Z","path":"2018/12/20/spock单元测试/","text":"","tags":[]},{"title":"gatling压力测试-maven版","date":"2018-12-20T07:50:35.000Z","path":"2018/12/20/gatling压力测试-maven版/","text":"","tags":[]},{"title":"异步servlet与spring异步任务","date":"2018-12-20T07:49:18.000Z","path":"2018/12/20/异步servlet与spring异步任务/","text":"","tags":[]},{"title":"springboot自定义starter","date":"2018-11-21T17:24:54.000Z","path":"2018/11/22/springboot自定义starter/","text":"","tags":[]},{"title":"IDEA Editor rest client使用","date":"2018-11-21T17:16:49.000Z","path":"2018/11/22/IDEA-Editor-rest-client使用/","text":"TODO editor rest client grammary test and validate environment","tags":[{"name":"idea","slug":"idea","permalink":"https://techzealot.github.io/tags/idea/"},{"name":"rest","slug":"rest","permalink":"https://techzealot.github.io/tags/rest/"},{"name":"test","slug":"test","permalink":"https://techzealot.github.io/tags/test/"}]},{"title":"linux进程后台运行","date":"2018-11-21T17:13:32.000Z","path":"2018/11/22/linux进程后台运行/","text":"TODO nohup &amp; setid disown screen jobs ,bg ,fg","tags":[{"name":"linux","slug":"linux","permalink":"https://techzealot.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://techzealot.github.io/tags/shell/"}]},{"title":"springboot优雅关机","date":"2018-11-21T17:07:09.000Z","path":"2018/11/22/springboot优雅关机/","text":"TODO start and stop as a linux service web container(tomcat ,undertow) gracefully shutdown gracefully shutdown shell script thread pool shutdown gracefully and shudownhook and spring application","tags":[{"name":"linux","slug":"linux","permalink":"https://techzealot.github.io/tags/linux/"},{"name":"springboot","slug":"springboot","permalink":"https://techzealot.github.io/tags/springboot/"}]},{"title":"Hello World","date":"2018-11-14T17:21:29.310Z","path":"2018/11/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[{"name":"test","slug":"test","permalink":"https://techzealot.github.io/tags/test/"}]},{"title":"springboot远程调试","date":"2018-11-14T16:09:50.000Z","path":"2018/11/15/springboot远程调试/","text":"springboot应用远程调试Java程序远程调试的原理是基于JDWP(Java Debug Wire Protocol),具体可参考JDWP 协议及实现;具体步骤如下： 远程代码必须和本地一致，否则可能出现无法预料的错误！ 在启动命令加上如下参数：-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=0.0.0.0:10009 -Xdebug是通知JVM工作在DEBUG模式下 -Xrunjdwp是通知JVM使用(java debug wire protocol)来运行调试环境 transport指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台 suspend指明，是否在调试客户端建立起来后，再执行JVM adress 表示远程调试提供访问的地址和端口，0.0.0.0代表本机所有ip，避免绑定到localhost，不能远程访问 在ide(eclipse,idea)中打开debug configurations，选择remote application，添加要调试的项目，选择attach模式，输入ip和调试端口，即命令中adress设置的内容，添加断点，debug操作与本地一样。 注意： attach模式下，远程应用必须先启动，否则会报connection refused异常，无法调试 要确定远程调试的端口能被访问到，阿里云必须在安全组中配置才能访问。","tags":[{"name":"springboot","slug":"springboot","permalink":"https://techzealot.github.io/tags/springboot/"},{"name":"调试","slug":"调试","permalink":"https://techzealot.github.io/tags/调试/"}]}]