[{"title":"(14)go接口","date":"2020-05-26T16:11:17.000Z","path":"2020/05/27/go接口/","text":"本章介绍go语言接口的基本知识 接口一组行为的集合 package inftype Retriever interface &#123; Get(url string) string&#125; 接口实现(duck typing)接口实现是隐式的，无需显式声明，接口与实现分离，由使用者定义 具备接口定义的行为，就称实现了接口 package infraimport ( \"io/ioutil\" \"net/http\")type Retriever struct &#123;&#125;//值接收者func (Retriever) Get(url string) string &#123; resp, err := http.Get(url) if err != nil &#123; panic(err) &#125; defer resp.Body.Close() bytes, _ := ioutil.ReadAll(resp.Body) return string(bytes)&#125; package testingtype Retriever struct &#123;&#125;//指针接收者func (*Retriever) Get(url string) string &#123; return \"this is a test website\"&#125; package mainimport ( \"fmt\" \"helloworld/downloader/inf\" \"helloworld/downloader/testing\")func main() &#123; url := \"https://www.imooc.com\" retriever := getRetriever() fmt.Println(retriever.Get(url)) typeSwitch(retriever) typeAssertion(retriever)&#125;func getRetriever() inf.Retriever &#123; return &amp;infra.Retriever&#123;&#125; //return infra.Retriever&#123;&#125; //return &amp;testing.Retriever&#123;&#125;&#125; 接口类型获取switchfunc typeSwitch(retriever inf.Retriever) &#123; switch retriever.(type) &#123; case *testing.Retriever: fmt.Printf(\"%T ,%v\\n\", retriever, retriever) case infra.Retriever: fmt.Printf(\"value receiver: %T\\n,%v\\n\", retriever, retriever) case *infra.Retriever: fmt.Printf(\"pointer receiver: %T\\n,%v\\n\", retriever, retriever) default: fmt.Println(\"other retriever\") &#125;&#125; type assertionfunc typeAssertion(retriever inf.Retriever) &#123; if testRetriever, ok := retriever.(*testing.Retriever); ok &#123; fmt.Printf(\"test : %T ,%v\\n\", testRetriever, testRetriever) &#125; if infraRetriever, ok := retriever.(infra.Retriever); ok &#123; fmt.Printf(\"infra : %T ,%v\\n\", infraRetriever, infraRetriever) &#125;&#125; 接口变量的构成 接口变量的类型 接口变量的值或指针： 具体是值还是指针取决于所实现方法的接收者类型 接口变量的使用 接口变量可以带有指针 接口变量采用值传递，由于可以包含一个指针因此几乎不需要使用接口变量的指针 指针接收者只能以指针方式使用，值接收者都可以 interface{}表示任何类型 package genericqueuetype Queue []interface&#123;&#125;//指针接收者传递的为地址值，操作时需要*(取指针)操作func (q *Queue) Push(v interface&#123;&#125;) &#123; *q = append(*q, v)&#125;func (q *Queue) Pop() interface&#123;&#125; &#123; head := (*q)[0] *q = (*q)[1:] return head&#125;func (q *Queue) IsEmpty() bool &#123; return len(*q) == 0&#125;","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(13) go依赖管理","date":"2020-05-10T15:20:33.000Z","path":"2020/05/10/go依赖管理/","text":"本章主要介绍go语言依赖管理 go语言依赖管理三个阶段 GOPATH -&gt; GOVENDOR -&gt; GOMOD GOPATH（废弃）第三方库依赖放在GOPATH下 ${GOPATH}/src/ |- - our project |- - lib1(src) |- - lib2(src) GOVENDOR（废弃） 每个项目有自己的vendor目录，存放第三方库 解决GOPATH下依赖不同版本的问题 ${GOPATH}/src/ |- - our project |- - - vendor ​ |- - - - lib-common-v1 |- - lib1(src) |- - - vendor ​ |- - - - lib-common-v2 |- - lib2(src) GOMOD（推荐）优势： 支持镜像 支持多版本管理 go.mod统一管理，简洁方便 由go 命令统一管理，用户不必关心目录 初始化 go mod init 添加依赖 go get 清理依赖 go mod tidy 迁移至GOMOD go mod init go build ./… GOPROXY国内镜像配置$ go env -w GO111MODULE=on$ go env -w GOPROXY=https://goproxy.cn,direct","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(12) go面向对象-扩展已有类型","date":"2020-05-10T15:19:34.000Z","path":"2020/05/10/go面向对象-扩展已有类型/","text":"本章主要介绍go语言中如何扩展已有类型 包的规定 为结构定义的方法必须放在同一个包内 可以是不同文件 基于包的规定，如何扩展系统类型和已有类型？ 如何扩充使用组合扩展tree.Node,新的包装对象新增后序遍历 //扩展已有类型type myTreeNode struct &#123; node *tree.Node&#125;func (myNode *myTreeNode) postOrder() &#123; if myNode == nil || myNode.node == nil &#123; return &#125; left := myTreeNode&#123;myNode.node.Left&#125; left.postOrder() right := myTreeNode&#123;myNode.node.Right&#125; right.postOrder() myNode.node.Print()&#125;func main() &#123; var root tree.Node fmt.Println(root) //&#123;0 &lt;nil&gt; &lt;nil&gt;&#125; root = tree.Node&#123;Value: 3&#125; root.Left = &amp;tree.Node&#123;&#125; root.Right = &amp;tree.Node&#123;Value: 5, Left: nil, Right: nil&#125; //指针也可用. root.Right.Left = new(tree.Node) root.Left.Right = tree.CreateNode(2) root.Right.Left.SetValue(4) root.Traverse() //0 2 3 4 5 fmt.Println() myNode := myTreeNode&#123;&amp;root&#125; myNode.postOrder() //2 0 4 5 3&#125; 定义别名type Queue []int//指针接收者传递的为地址值，操作时需要*(取指针)操作func (q *Queue) Push(v int) &#123; *q = append(*q, v)&#125;func (q *Queue) Pop() int &#123; head := (*q)[0] *q = (*q)[1:] return head&#125;func (q *Queue) IsEmpty() bool &#123; return len(*q) == 0&#125; 使用内嵌 使用匿名的成员变量进行组合,语法糖,减少代码量,相当于对匿名成员的代理，不同于继承 新对象中定义相同方法时会shadow组合成员的同名方法，可通过组合成员的默认名称调用组合成员的原方法 package embededimport \"helloworld/tree\"//内嵌 使用匿名的成员变量进行组合,语法糖,减少代码量,相当于对匿名成员的代理type ENode struct &#123; //默认名称为简单结构名Node *tree.Node&#125;func (myNode *ENode) PostOrder() &#123; if myNode == nil || myNode.Node == nil &#123; return &#125; left := ENode&#123;myNode.Left&#125; left.postOrder() right := ENode&#123;myNode.Right&#125; right.postOrder() myNode.Print()&#125;//shadow method for tree.Nodefunc (myNode *ENode) Traverse() &#123; fmt.Println(\"this is a shadow method for tree.Node\")&#125; func main() &#123; var root embeded.ENode fmt.Println(root) //&#123;0 &lt;nil&gt; &lt;nil&gt;&#125; root = embeded.ENode&#123;Node: &amp;tree.Node&#123;Value: 3&#125;&#125; root.Left = &amp;tree.Node&#123;&#125; root.Right = &amp;tree.Node&#123;Value: 5, Left: nil, Right: nil&#125; //指针也可用. root.Right.Left = new(tree.Node) root.Left.Right = tree.CreateNode(2) root.Right.Left.SetValue(4) root.Traverse() //this is a shadow method for tree.Node root.Node.Traverse() //0 2 3 4 5 fmt.Println() root.PostOrder() //2 0 4 5 3&#125; 别名和组合的比较定义别名：最简单（无法与组合无缝切换，要修改代码） 使用组合：最常用 使用内嵌：省下很多代码（不直观）","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(11) go面向对象-包和封装","date":"2020-05-10T15:19:01.000Z","path":"2020/05/10/go面向对象-包和封装/","text":"本章主要介绍go语言的包和封装 封装 名字一般使用CamelCase 首字母大写表示public（包外可见） 首字母小写表示private（包内可见） 包 每个目录下只能有一个包（一个包可分散在多个文件），包名不必与目录名相关 main包包含可执行入口，main函数不在main包不能运行,不同目录下的main包成员不能互相访问 为结构定义的方法必须放在同一个包内，但可以是不同的文件（方便协作开发） 工程化组织将每个含有main函数的文件分散在不同的目录中，通常包名与文件名相同 可参考golang.org/x/tools/cmd","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(10) go面向对象-结构体和方法","date":"2020-05-10T15:18:20.000Z","path":"2020/05/10/go面向对象-结构体和方法/","text":"本章主要介绍go语言结构体的使用及方法的定义 面向对象 go仅支持封装，不支持继承和多态，通过接口和组合实现面向对象 go只有struct，没有class，没有构造函数，但有各种灵活的构造方式 结构的创建type treeNode struct &#123; value int left, right *treeNode&#125;//返回了局部变量，变量分配由编译器决定分配在堆上还是栈上func createNode(value int) *treeNode &#123; return &amp;treeNode&#123;value: value&#125;&#125;func main() &#123; var root treeNode fmt.Println(root) //&#123;0 &lt;nil&gt; &lt;nil&gt;&#125; root = treeNode&#123;value: 3&#125; root.left = &amp;treeNode&#123;&#125; root.right = &amp;treeNode&#123;5, nil, nil&#125; //指针也可用. root.right.left = new(treeNode) nodes := []treeNode&#123; &#123;value: 3&#125;, &#123;&#125;, &#123;6, nil, nil&#125;, &#125; fmt.Println(nodes)//[&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; &#123;0 &lt;nil&gt; &lt;nil&gt;&#125; &#123;6 &lt;nil&gt; &lt;nil&gt;&#125;]&#125; 不论地址还是结构本身都使用 . 来访问成员 定义方法 struct的方法就是普通函数，多声明了接收者 指针接收者和值接收者均可用实例去调用，由编译器根据真实情况决定传递值还是指针 只有使用指针才能改变结构内部 nil指针也可以调用方法 func (t T) m()&#123; &#125;类似于func m(t T)&#123; &#125;因此struct 为nil时仍可以调用方法 type treeNode struct &#123; value int left, right *treeNode&#125;//值接收者，值传递func (node treeNode) print() &#123; fmt.Print(node.value,\" \")&#125;//指针接收者func (node *treeNode) setValue(value int) &#123; node.value = value&#125; nil指针不同于null，nil可以调用方法，其他语言中null只能判断是否为null func (node *treeNode) nilTest() &#123; if node == nil &#123; fmt.Println(\"nil invoker\") &#125; //此处获取不到值，仍然会panic，但是可以调用进来 //fmt.Println(node.value)&#125;func main() &#123; var pRoot *treeNode pRoot.nilTest() //nil invoker&#125; 中序遍历//中序遍历,递归func (node *treeNode) traverse() &#123; if node == nil &#123; return &#125; node.left.traverse() node.print() node.right.traverse()&#125;func main() &#123; var root treeNode fmt.Println(root) //&#123;0 &lt;nil&gt; &lt;nil&gt;&#125; root = treeNode&#123;value: 3&#125; root.left = &amp;treeNode&#123;&#125; root.right = &amp;treeNode&#123;5, nil, nil&#125; //指针也可用. root.right.left = new(treeNode) root.left.right = createNode(2) root.right.left.setValue(4) root.traverse() //0 2 3 4 5&#125; 值接收者vs指针接收者 要改变内容必须使用指针接收者 结构过大也考虑指针接收者 一致性（建议，不强制）：如有指针接收者最好全为指针接收者 值接收者为go特有 值/指针接收者均可接收值/指针，亦即：值接收者和指针接收者并不影响调用者的调用方式","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(9) go字符和字符串","date":"2020-05-10T15:17:37.000Z","path":"2020/05/10/go字符和字符串/","text":"todo","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(8) go map","date":"2020-05-10T15:17:16.000Z","path":"2020/05/10/go-Map/","text":"本章主要介绍go语言map的定义及使用 map的声明和初始化 m :=map[K]V map声明的时候默认值是nil ，此时进行取值，返回的是对应类型的零值 两种初始化方式：map[K]V{}或make(map[K]V,cap) 通过fmt打印map时，空map和nil map结果都为map[],所以断定map是空还是nil应该通过map == nil来判断 未初始化的map是nil，它与一个空map基本等价，只是nil的map不允许往里面添加值。（A nil map is equivalent to an empty map except that no elements may be added）因此，map是nil时，取值是不会报错的（取不到而已），但增加值会报错。 Most operations on maps, including lookup, delete, len, and range loops, are safe to perform on a nil map reference, since it behaves like an emtpy map. But storing to a nil map cause a panic. func main() &#123; //1 m := map[string]string&#123; \"name\": \"tom\", \"age\": \"20\", &#125; fmt.Println(m) //map[age:20 name:tom] //2 或m2 := make(map[string]int,cap) m2 := make(map[string]int) //map[] fmt.Println(m2) //map[] m2[\"a\"] = 1 fmt.Println(m2) //3 var m3 map[string]int //nil fmt.Println(m3) //map[] //** this will panic m3[\"a\"] = 1 //this will not panic now delete(m3, \"test\")&#125; map的遍历 map底层为hashmap，是无序的 使用len(m)可获取元素个数 for k, v := range m &#123; fmt.Println(k, v)&#125;//只获取keyfor k := range m &#123; fmt.Println(k)&#125;//只获取vfor _,v := range m &#123; fmt.Println(v)&#125; map的get 当获取不存在的key时会返回zero value v,exists=map[key] if v, ok := m[\"test\"]; ok &#123; fmt.Println(v, ok)&#125; map的删除 在删除的时候会标记该key为empty，不会回收内存 delete(m,key) map的k,v的类型k的类型 map使用hash表，因此key必须可以比较相等 除slice,map,function外均可作为key 不包含slice,map,function字段的struct也可作为key 类型的比较 slice不可以 s1 ==s2,只可以与nil比较，但可以借助于reflect.DeepEqual(arr1, arr2)比较，返回true或false,此外map也可以通过reflect.DeepEqual(m1, m2)比较 不同结构的结构体不可以比较，但同一类型的实例值是可以比较的。 两个 struct完全相等， 意味着里面的所有变量的值都完全相等 v的类型 可以为任意类型 map作为函数的参数 Golang中是没有引用传递的，均为值传递。这意味着传递的是数据的拷贝。那么map本身是引用类型，作为形参或返回参数的时候，传递的是地址的拷贝，扩容时也不会改变这个地址。 func deleteMap(m map[string]string) &#123; delete(m, \"name\")&#125;func main() &#123; //1 m := map[string]string&#123; \"name\": \"tom\", \"age\": \"20\", &#125; fmt.Println(m) //map[age:20 name:tom] deleteMap(m) fmt.Println(\"after delete:\", m) //after delete: map[age:20]&#125; map的底层数据结构todo map的并发安全 map是非并发安全的 可以使用sync.Map map的gc回收机制 map在golang里是只增不减的一种数组结构，在删除的时候会标记该key为empty，不会回收内存 delete是不会真正把map释放，真正释放内存的做法为： m =nil //交由垃圾回收器回收 map实战案例：寻找最长不含重复字符的子串","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(7) go切片","date":"2020-05-10T15:16:41.000Z","path":"2020/05/10/go切片/","text":"本章主要介绍slice的用法、扩展及操作 slice的定义 slice是对数组的一个view arr[m:n] 是对数组arr的一个slice,本身没有数据，是对数组arr从下标m到n-1的元素的view，为左闭右开，m和n省略是分别代表首尾 func main() &#123; arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; fmt.Println(\"arr[2:6] =\", arr[2:6]) //arr[2:6] = [2 3 4 5] fmt.Println(\"arr[2:] =\", arr[2:]) //arr[2:] = [2 3 4 5 6 7] fmt.Println(\"arr[:6] =\", arr[:6]) //arr[:6] = [0 1 2 3 4 5] fmt.Println(\"arr[:] =\", arr[:]) //arr[:] = [0 1 2 3 4 5 6 7]&#125; slice作为参数用作参数传递时表示形式为 ：[]T (数组定义不加长度即为slice) //将会更改slice对应的数组元素func updateSlice(s []int) &#123; //会更改slice的第0个元素对应的数组元素 s[0] = 100&#125;func main() &#123; arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; updateSlice(arr[2:]) fmt.Println(arr) //[0 1 100 3 4 5 6 7] updateSlice(arr[:]) fmt.Println(arr) //[100 1 100 3 4 5 6 7]&#125; resliceslice可以再次slice,而且是对同一个数组的view func main() &#123; arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; s2 := arr[:][:5] fmt.Println(\"s2=\", s2) //s2= [0 1 2 3 4] s3 := s2[2:] fmt.Println(\"s3=\", s3) //s3= [2 3 4]&#125; slice的扩展func main() &#123; arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; s1 := arr[2:6] fmt.Println(\"s1=\", s1) //s1= [2 3 4 5] //s1[4]不存在,但用slice时可以扩展 s2 := s1[3:5] fmt.Println(\"s2=\", s2) //s2= [5 6]&#125; slice的扩展示意图 slice的底层实现 slice的底层实现 slice可以向后扩展，但不可以向前扩展 s[i]不可以超越len(s),向后扩展不可以超越底层数组cap(s) func main() &#123; arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; s1 := arr[2:6] fmt.Printf(\"s1=%v ,len(s1)=%d ,cap(s1)=%d \\n\", s1, len(s1), cap(s1)) //s1=[2 3 4 5] ,len(s1)=4 ,cap(s1)=6 //s1[4]不存在,但用slice时可以扩展 s2 := s1[3:5] fmt.Printf(\"s2=%v ,len(s2)=%d ,cap(s2)=%d \\n\", s2, len(s2), cap(s2)) //ss2=[5 6] ,len(s2)=2 ,cap(s2)=3&#125; slice的操作：添加，创建，复制，删除 添加元素时如果超过底层数组cap，系统会重新分配更大的底层数组并会拷贝原来数组的数据 由于append为值传递，且可能引起扩容(导致底层ptr,len,cap发生变化)，必须接收append的返回值 固定用法：s =append(s,val) 添加func main() &#123; arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; s1 := arr[2:6] s2 := s1[3:5] //arr[8]被覆盖为10 s3 := append(s2, 10) s4 := append(s3, 10) s5 := append(s4, 10) //对切片的插入一旦超过底层数组cap，便会生成一个更大（2^n）的新数组并会拷贝原来数组的数据 //s4 s5 no longer view arr fmt.Println(\"s3 ,s4 ,s5 =\", s3, s4, s5) //s3 ,s4 ,s5 = [5 6 10] [5 6 10 10] [5 6 10 10 10] fmt.Println(arr) //[0 1 2 3 4 5 6 10]&#125; 创建 var []T s :=[]T{} make([]T,len) make([]T,len,cap) arr[m:n] func printSlice(s []int) &#123; fmt.Printf(\"%v ,len= %d ,cap= %d \\n\", s, len(s), cap(s))&#125;func main() &#123; var s []int //zero value for slice is [] printSlice(s) s2 := make([]int, 16) s3 := make([]int, 10, 32) printSlice(s2) printSlice(s3)&#125; 复制 copy（dst,src） //把src的元素拷贝到dst中 func printSlice(s []int) &#123; fmt.Printf(\"%v ,len= %d ,cap= %d \\n\", s, len(s), cap(s))&#125;func main() &#123; var s []int //zero value for slice is [] printSlice(s) s1 := []int&#123;2, 4, 6, 8&#125; s2 := make([]int, 16) s3 := make([]int, 10, 32) printSlice(s2) printSlice(s3) copy(s2, s1) fmt.Println(s2) //[2 4 6 8 0 0 0 0 0 0 0 0 0 0 0 0]&#125; 删除删除第n个元素 s=append(s[:n],s[n+1:]…) func main() &#123; var s []int //zero value for slice is [] printSlice(s) s1 := []int&#123;2, 4, 6, 8&#125; s2 := make([]int, 16) s3 := make([]int, 10, 32) printSlice(s2) printSlice(s3) copy(s2, s1) fmt.Println(s2) //[2 4 6 8 0 0 0 0 0 0 0 0 0 0 0 0] //删除下标为3的元素 s2 = append(s2[:3], s2[4:]...) printSlice(s2) //[2 4 6 0 0 0 0 0 0 0 0 0 0 0 0] ,len= 15 ,cap= 16&#125; 删除首尾//删除头s =s[1:]//删除尾s =s[:len(s)-1]","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(6) go数组","date":"2020-05-08T17:36:17.000Z","path":"2020/05/09/go数组/","text":"本章主要介绍数组的定义、使用、遍历、值类型 数组定义func main() &#123; //默认初始化 var arr1 [5]int arr2 := [3]int&#123;1, 3, 5&#125; //编译器推断 arr3 := [...]int&#123;2, 4, 6, 8, 10&#125; fmt.Println(arr1, arr2, arr3) //[0 0 0 0 0] [1 3 5] [2 4 6 8 10] //4行5列二维数组 var grade [4][5]bool fmt.Println(grade) //[[false false false false false] [false false false false false] [false false false false false] [false false false false false]]&#125; 数组的遍历func main() &#123; //编译器推断 arr3 := [...]int&#123;2, 4, 6, 8, 10&#125; //强烈不推荐，其他语言的做法 for i := 0; i &lt; len(arr3); i++ &#123; fmt.Println(arr3[i]) &#125; for i := range arr3 &#123; fmt.Println(arr3[i]) &#125; //推荐做法,可同时获取索引和值,_可以省略变量 for _, v := range arr3 &#123; fmt.Println(v) &#125;&#125; range 的好处：简单明确，可同时获取索引和对应值 数组是值类型//数组的值会拷贝过来，原数组不会被改变func printArray(arr [5]int) &#123; arr[0] = 100 for i, v := range arr &#123; fmt.Println(i, v) &#125;&#125;//可传递指针来改变原数组func printArrayWithEffect(arr *[5]int) &#123; //此处等价于 (*arr)[0] = 100,语法处理，arr并不是数组的头指针（不同于C） arr[0] = 100 for i, v := range arr &#123; fmt.Println(i, v) &#125;&#125;func main() &#123; //编译器推断 arr3 := [...]int&#123;2, 4, 6, 8, 10&#125; printArray(arr3) fmt.Println(arr3) //[2 4 6 8 10] printArrayWithEffect(&amp;arr3) fmt.Println(arr3) //[100 4 6 8 10]&#125; 在go语言中一般不使用数组或数组指针作为参数，而是使用切片（详见下章）","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(5) go指针","date":"2020-05-08T16:45:14.000Z","path":"2020/05/09/go指针/","text":"本章主要介绍go语言指针用法及注意事项 go语言指针不能参与运算，但可以改变指向func main() &#123; var a int = 2 var pa *int = &amp;a *pa = 3 fmt.Println(a, pa, *pa, &amp;pa, &amp;a) //3 0xc00000a0e8 3 0xc000006028 0xc00000a0e8&#125; go语言函数参数是值传递go语言只有值传递一种形式： 默认通过数据拷贝进行值传递，可通过传递指针(地址值)实现传递引用的效果 因此在设计对象时就应该考虑传递形式 func passByValue(a int) &#123; a++&#125;func passByRef(a *int) &#123; *a++&#125;func main() &#123; a := 2 passByValue(a) fmt.Println(a) //2 passByRef(&amp;a) fmt.Println(a) //3&#125; go语言支持多重赋值两个变量交换不需要引入第三个参数 a,b int=3,4a,b=b,a 交换函数实现//推荐做法func swapNoSideEffect(a, b int) (int, int) &#123; return b, a&#125;func swap(a, b *int) &#123; *a, *b = *b, *a&#125;func main() &#123; c, d := 5, 6 swap(&amp;c, &amp;d) fmt.Println(c, d) //6,5 c, d = swapNoSideEffect(c, d) fmt.Println(c, d) //5,6 var e int c, d, e = d, c, d/c fmt.Println(c, d, e) //6 5 1 将右侧变量先运算替换，然后一次赋多值&#125; 指针变量与非指针变量 指针变量pa的值为所指向变量的地址值，*pa 取所指向变量 &amp;pa 取该变量的地址 非指针变量pb的值为 变量值 *pb 非法 &amp;pb 取该变量的地址 var pa *intfmt.Println(*pa)fmt.Println(&amp;pa)var pb intfmt.Println(&amp;pb)//fmt.Println(*pb) //compile error","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(4) go函数","date":"2020-05-07T16:51:42.000Z","path":"2020/05/08/go函数/","text":"本章主要介绍了go的函数定义及使用，函数式编程，可变参数列表 go函数可以返回多个值,而且可以命名 //不要滥用多值返回，一般最后一个为errorfunc div(a, b int) (q, r int) &#123; return a / b, a % b&#125;func evalSilent(a, b int, op string) (int, error) &#123; switch op &#123; case \"+\": return a + b, nil case \"-\": return a - b, nil case \"*\": return a * b, nil case \"/\": return a / b, nil case \"%\": _, r := div(a, b) return r, nil default: return 0, fmt.Errorf(\"unsupport op : %s\", op) &#125;&#125;func main() &#123; fmt.Println(div(13, 3)) if result, err := evalSilent(13, 3, \"x\"); err != nil &#123; fmt.Println(\"error\", err) &#125; else &#123; fmt.Println(result) &#125;&#125; 函数式编程函数参数和返回值也可以是函数 func apply(op func(int, int) int, a, b int) int &#123; p := reflect.ValueOf(op).Pointer() opName := runtime.FuncForPC(p).Name() fmt.Printf(\"calling function %s with args (%d,%d) \\n\", opName, a, b) return op(a, b)&#125;func main() &#123; //匿名函数 fmt.Println(apply(func(a int, b int) int &#123; return int(math.Pow(float64(a), float64(b))) &#125;, 3, 4))&#125; 可变参数func sum(numbers ...int) int &#123; s := 0 for i := range numbers &#123; s += numbers[i] &#125; return s&#125;func main() &#123; fmt.Println(sum(1, 2, 3, 4, 5))&#125;","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(3) go控制结构","date":"2020-05-07T15:30:44.000Z","path":"2020/05/07/go控制结构/","text":"本章主要介绍了go语言的流程控制结构if,switch,for的常见用法 1. ifform 1 func main() &#123; const filename = \"abc.txt\" file, err := ioutil.ReadFile(filename) if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Printf(\"%s\\n\", file) &#125;&#125; form 2（推荐） func main() &#123; const filename = \"abc.txt\" //file作用域在if语句内 if file, err := ioutil.ReadFile(filename); err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Printf(\"%s\\n\", file) &#125;&#125; 2. switchswitch默认会break除非使用fallthrough form 1 func eval(a, b int, op string) int &#123; switch op &#123; case \"+\": return a + b case \"-\": return a - b case \"*\": return a * b case \"/\": return a / b default: panic(\"unsupported op:\" + op) &#125;&#125; form 2: switch后没有表达式，case中有表达式 func grade(score int) string &#123; g := \"\" switch &#123; case score &lt; 0 || score &gt; 100: panic(fmt.Sprintf(\"wrong score %d \\n\", score)) case score &lt; 60: g = \"F\" case score &lt; 80: g = \"C\" case score &lt; 90: g = \"B\" case score &lt; 00: g = \"A\" &#125; return g&#125; 3. forform 1 for的条件里不需要括号 for可以省略初始条件、结束表达式、自增条件 func loop() &#123; sum := 0 for i := 0; i &lt; 100; i++ &#123; sum += i &#125;&#125; form 2 省略初始条件 func convertToBin(n int) string &#123; if n == 0 &#123; return \"0\" &#125; result := \"\" for ; n &gt; 0; n /= 2 &#123; lsb := n % 2 result = strconv.Itoa(lsb) + result &#125; return result&#125; form 3 省略结束条件、递增条件，此时相当于while func printFile(filename string) &#123; file, err := os.Open(filename) if err != nil &#123; panic(err) &#125; scanner := bufio.NewScanner(file) for scanner.Scan() &#123; fmt.Println(scanner.Text()) &#125;&#125; form 4 省略结束条件 func forever() &#123; for &#123; fmt.Println(\"forever\") &#125;&#125;","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(2) go语言常量","date":"2020-05-07T14:41:21.000Z","path":"2020/05/07/go语言常量/","text":"本章主要介绍了go语言的常量、枚举及iota的使用 1. 常量const ( d = 1 e = 2)func consts() &#123; const filename = \"abc.txt\" //常量可以当做各种类型使用，相当于文本替换 const a, b = 3, 4 var c int //此处无需强转 c = int(math.Sqrt(a*a + b*b)) fmt.Println(c)&#125; 2. 枚举类型func enums() &#123; /*const ( cpp = 0 java = 1 python = 2 golang = 3 )*/ const ( cpp = iota //0 _ //1 python // 2 golang //3 ) //b kb mb gb tb pb const ( b = 1 &lt;&lt; (10 * iota) //1 &lt;&lt; (10*0) kb //1 &lt;&lt; (10*1) mb //1 &lt;&lt; (10*2) gb //1 &lt;&lt; (10*3) tb //1 &lt;&lt; (10*4) pb //1 &lt;&lt; (10*5) ) fmt.Println(b, kb, mb, gb, tb, pb) //1 1024 1048576 1073741824 1099511627776 1125899906842624 fmt.Println(cpp, python, golang) //0 2 3&#125; iota 自增量种子 可以参与运算","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"(1) go语言变量","date":"2020-05-06T17:56:58.000Z","path":"2020/05/07/go语言变量/","text":"本章主要介绍了变量的定义及使用，基本数据类型，类型转换 1. 变量定义go语言变量一旦定义便会有一个zero value 1.1 局部变量var a int =3var a,b int =3,4//类型推断var a,b,c,d = 3,4,true,\"abc\"// := 定义并初始化 推荐使用a,b,c,d := 3,4,true,\"abc\" 1.2 包内变量//包内部变量必须使用var定义，无全局变量var aa = 1// () 可以省略多个varvar ( bb = 2 cc = 3 dd = 4) 1.3 复数使用//验证欧拉公式func euler() &#123; c := 3 + 4i fmt.Println(cmplx.Abs(c)) eu := cmplx.Pow(math.E, 1i*math.Pi) + 1 fmt.Println(eu) eu = cmplx.Exp(1i*math.Pi) + 1 fmt.Printf(\"%3f \\n\", eu)&#125; 2. 类型转换必须显式声明//类型转换采用 T() 形式func triangle() &#123; a, b := 3, 4 var c int c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c)&#125; 3. 基本数据类型整型 类型 描述 uint8 无符号 8位整型 (0 到 255) uint16 无符号 16位整型 (0 到 65535) uint32 无符号 32位整型 (0 到 4294967295) uint64 无符号 64位整型 (0 到 18446744073709551615) int8 有符号 8位整型 (-128 到 127) int16 有符号 16位整型 (-32768 到 32767) int32 有符号 32位整型 (-2147483648 到 2147483647) int64 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) 特殊整型 类型 描述 uint 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 浮点型float32和float64 复数complex64和complex128 c := 3 + 4ifmt.Println(cmplx.Abs(c)) 布尔值Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。 注意： 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换 字符串Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(&quot;)中的内容，可以在Go语言的源码中直接添加非ASCII码字符 Go语言中要定义一个多行字符串时，就必须使用反引号字符 str := \"hello world\"ch := \"中文\"const str = ` 第一行第二行第三行\\r\\n`fmt.Println(str) byte和rune类型Go 语言的字符有以下两种： uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 UTF-8字符。 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。","tags":[{"name":"go","slug":"go","permalink":"https://techzealot.github.io/tags/go/"}]},{"title":"MAT排查问题思路","date":"2020-01-16T05:50:39.000Z","path":"2020/01/16/MAT排查问题思路/","text":"MAT分析jvm内存转储文件思路及操作： 查看leak suspect 查看Histogram分布 (按retainSize降序) merge shortest path to GC root (按retainSize降序) list objects with incoming/outcoming (按retainSize降序) 在big map上执行java collection &gt; collections group by size (按retainSize降序) 1-5按情况交叉执行","tags":[{"name":"jvm","slug":"jvm","permalink":"https://techzealot.github.io/tags/jvm/"},{"name":"mat","slug":"mat","permalink":"https://techzealot.github.io/tags/mat/"}]},{"title":"truffle与graalVM","date":"2019-03-04T17:35:38.000Z","path":"2019/03/05/truffle与graalVM/","text":"","tags":[]},{"title":"TCP/IP协议详解","date":"2019-02-20T16:52:24.000Z","path":"2019/02/21/TCP-IP协议详解/","text":"","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://techzealot.github.io/tags/TCP-IP/"}]},{"title":"java Class文件结构","date":"2019-02-20T15:23:35.000Z","path":"2019/02/20/java-Class文件结构/","text":"todo","tags":[{"name":"JVM","slug":"JVM","permalink":"https://techzealot.github.io/tags/JVM/"},{"name":"class","slug":"class","permalink":"https://techzealot.github.io/tags/class/"},{"name":"编译器","slug":"编译器","permalink":"https://techzealot.github.io/tags/编译器/"}]},{"title":"guice官方文档中文版","date":"2018-12-21T05:02:48.000Z","path":"2018/12/21/guice官方文档中文版/","text":"","tags":[]},{"title":"springboot实现指定范围内随机选取可用端口","date":"2018-12-20T07:57:04.000Z","path":"2018/12/20/springboot实现指定范围内随机选取可用端口/","text":"","tags":[]},{"title":"DeferredResult实现http long pulling","date":"2018-12-20T07:55:18.000Z","path":"2018/12/20/DeferredResult实现http-long-pulling/","text":"","tags":[]},{"title":"spock单元测试","date":"2018-12-20T07:53:18.000Z","path":"2018/12/20/spock单元测试/","text":"","tags":[]},{"title":"gatling压力测试-maven版","date":"2018-12-20T07:50:35.000Z","path":"2018/12/20/gatling压力测试-maven版/","text":"","tags":[]},{"title":"异步servlet与spring异步任务","date":"2018-12-20T07:49:18.000Z","path":"2018/12/20/异步servlet与spring异步任务/","text":"","tags":[]},{"title":"springboot自定义starter","date":"2018-11-21T17:24:54.000Z","path":"2018/11/22/springboot自定义starter/","text":"","tags":[]},{"title":"IDEA Editor rest client使用","date":"2018-11-21T17:16:49.000Z","path":"2018/11/22/IDEA-Editor-rest-client使用/","text":"TODO editor rest client grammary test and validate environment","tags":[{"name":"idea","slug":"idea","permalink":"https://techzealot.github.io/tags/idea/"},{"name":"rest","slug":"rest","permalink":"https://techzealot.github.io/tags/rest/"},{"name":"test","slug":"test","permalink":"https://techzealot.github.io/tags/test/"}]},{"title":"linux进程后台运行","date":"2018-11-21T17:13:32.000Z","path":"2018/11/22/linux进程后台运行/","text":"TODO nohup &amp; setid disown screen jobs ,bg ,fg","tags":[{"name":"linux","slug":"linux","permalink":"https://techzealot.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://techzealot.github.io/tags/shell/"}]},{"title":"springboot优雅关机","date":"2018-11-21T17:07:09.000Z","path":"2018/11/22/springboot优雅关机/","text":"TODO start and stop as a linux service web container(tomcat ,undertow) gracefully shutdown gracefully shutdown shell script thread pool shutdown gracefully and shudownhook and spring application","tags":[{"name":"linux","slug":"linux","permalink":"https://techzealot.github.io/tags/linux/"},{"name":"springboot","slug":"springboot","permalink":"https://techzealot.github.io/tags/springboot/"}]},{"title":"Hello World","date":"2018-11-14T17:21:29.310Z","path":"2018/11/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[{"name":"test","slug":"test","permalink":"https://techzealot.github.io/tags/test/"}]},{"title":"springboot远程调试","date":"2018-11-14T16:09:50.000Z","path":"2018/11/15/springboot远程调试/","text":"springboot应用远程调试Java程序远程调试的原理是基于JDWP(Java Debug Wire Protocol),具体可参考JDWP 协议及实现;具体步骤如下： 远程代码必须和本地一致，否则可能出现无法预料的错误！ 在启动命令加上如下参数：-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=0.0.0.0:10009 -Xdebug是通知JVM工作在DEBUG模式下 -Xrunjdwp是通知JVM使用(java debug wire protocol)来运行调试环境 transport指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台 suspend指明，是否在调试客户端建立起来后，再执行JVM adress 表示远程调试提供访问的地址和端口，0.0.0.0代表本机所有ip，避免绑定到localhost，不能远程访问 在ide(eclipse,idea)中打开debug configurations，选择remote application，添加要调试的项目，选择attach模式，输入ip和调试端口，即命令中adress设置的内容，添加断点，debug操作与本地一样。 注意： attach模式下，远程应用必须先启动，否则会报connection refused异常，无法调试 要确定远程调试的端口能被访问到，阿里云必须在安全组中配置才能访问。","tags":[{"name":"springboot","slug":"springboot","permalink":"https://techzealot.github.io/tags/springboot/"},{"name":"调试","slug":"调试","permalink":"https://techzealot.github.io/tags/调试/"}]}]